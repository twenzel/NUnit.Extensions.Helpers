using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NUnit.Extensions.Helpers.Generators.Internal;
using NUnit.Extensions.Helpers.Generators.Models;

namespace NUnit.Extensions.Helpers.Generators;

[Generator]
public partial class ConstructorParameterTestGenerator : BaseGenerator, IIncrementalGenerator
{
	/// <summary>
	/// Called to initialize the generator and register generation steps via callbacks
	/// on the <paramref name="context" />
	/// </summary>
	/// <param name="context">The <see cref="T:Microsoft.CodeAnalysis.IncrementalGeneratorInitializationContext" /> to register callbacks on</param>
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		AddAttributes(context);

		var classesToGenerate =
				context.SyntaxProvider
					.ForAttributeWithMetadataName<ConstructorParameterTestGeneratorModel?>($"{Sources.NAMESPACE}.{Sources.GENERATE_CONSTRUCTOR_PARAMETER_TESTS_ATTRIBUTE}",
						predicate: static (node, _) => node is ClassDeclarationSyntax,
						transform: GetTypeToGenerate)
					.WithTrackingName(TrackingNames.InitialExtraction);

		context.RegisterSourceOutput(classesToGenerate, Generate);
	}

	private void AddAttributes(IncrementalGeneratorInitializationContext context)
	{
		if (AddMarkerAttributes)
		{
			context.RegisterPostInitializationOutput(context =>
			{
				context.AddSource($"{Sources.GENERATE_CONSTRUCTOR_PARAMETER_TESTS_ATTRIBUTE}{GENERATED_FILE_SUFFIX}", SourceText.From(Sources.GENERATE_CONSTRUCTOR_PARAMETER_TESTS_ATTRIBUTE_SOURCE, Encoding.UTF8));
			});
		}
	}

	static ConstructorParameterTestGeneratorModel? GetTypeToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken ct)
	{
		var list = new List<INamedTypeSymbol>();

		if (context.TargetSymbol is not INamedTypeSymbol targetTypeSymbol)
			return null;

		foreach (var attribute in context.Attributes)
		{
			if (attribute.ConstructorArguments.Length == 0)
				continue;

			if (attribute.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol)
				list.Add(typeSymbol);
		}

		ct.ThrowIfCancellationRequested();

		return ConstructorParameterTestGeneratorModelProvider.GetDescriptor(targetTypeSymbol, list);
	}

	void Generate(SourceProductionContext spc, ConstructorParameterTestGeneratorModel? testDescriptor)
	{
		if (testDescriptor is { } test)
		{
			try
			{
				OnGenerate(spc, test);
			}
			catch (Exception ex)
			{
				spc.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.Error, null, $"({test.ClassName}) {ex.Message}"));
			}
		}
	}

	private void OnGenerate(SourceProductionContext context, ConstructorParameterTestGeneratorModel testToGenerate)
	{
		var cancellationToken = context.CancellationToken;
		if (cancellationToken.IsCancellationRequested)
			return;


		var stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("// <auto-generated/>");
		AddHeader(stringBuilder);
		stringBuilder.AppendLine("using System;");
		stringBuilder.AppendLine("using FluentAssertions;");
		stringBuilder.AppendLine("using Moq;");
		stringBuilder.AppendLine();
		stringBuilder.AppendLine($"namespace {testToGenerate.NameSpace};");
		stringBuilder.Append($"partial class {testToGenerate.ClassName}");

		if (!string.IsNullOrEmpty(testToGenerate.BaseType))
			stringBuilder.AppendLine($" : {testToGenerate.BaseType}");
		else
			stringBuilder.AppendLine();

		stringBuilder.AppendLine("{");

		AddTests(testToGenerate, stringBuilder);

		stringBuilder.AppendLine("}");

		string fileName;

		if (!string.IsNullOrEmpty(testToGenerate.BaseType))
			fileName = $"{testToGenerate.BaseType}.{testToGenerate.ClassName}";
		else
			fileName = $"{testToGenerate.NameSpace}.{testToGenerate.ClassName}";

		context.AddSource($"{fileName}_CPT{GENERATED_FILE_SUFFIX}", SourceText.From(stringBuilder.ToString(), Encoding.UTF8));

	}

	private static void AddTests(ConstructorParameterTestGeneratorModel testToGenerate, StringBuilder stringBuilder)
	{
		foreach (var classToGenerate in testToGenerate.TestClasses)
		{
			foreach (var constructors in classToGenerate.Constructors)
			{
				foreach (var parameter in constructors.Parameters)
				{
					var parameterName = FirstCharUpper(parameter.ParameterName);
					var parameterValues = GetParameterValues(constructors.Parameters, parameter);

					stringBuilder.AppendLine($$"""
	[Test]
	public void Throws_Exception_When_{{parameterName}}_Is_Null()
	{
		Action action = () => new {{classToGenerate.Name}}({{parameterValues}});
		action.Should().Throw<ArgumentNullException>().Which.ParamName.Should().Be("{{parameter.ParameterName}}");
	}

""");
				}
			}
		}
	}

	private static string GetParameterValues(EquatableList<ParameterModel> parameters, ParameterModel currentParameter)
	{
		var builder = new StringBuilder();
		var useNull = false;

		foreach (var parameter in parameters)
		{
			if (builder.Length > 0)
				builder.Append(", ");

			if (parameter == currentParameter)
				useNull = true;

			if (useNull)
				builder.Append("null");
			else
				builder.Append($"Mock.Of<{parameter.TypeName}>()");
		}

		return builder.ToString();
	}

	private static string FirstCharUpper(string value)
	{
		if (value == null)
			throw new ArgumentNullException(nameof(value), "The given string should not be empty to convert to pascal case.");

		if (value.Length == 1)
			return value.ToUpper();

		return char.ToUpper(value[0]) + value.Substring(1);
	}
}
